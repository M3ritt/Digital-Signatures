<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title> Digital Signatures </title>
</head>

<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='possible_style.css') }}">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<body>
<div class="sidenav">
    <a href="/"> Homepage </a>
    <button class="dropdown-btn"> Digital Signature
        <i class="fa fa-caret-down"></i>
    </button>
    <div class="dropdown-container">
        <a href="/digital_signature">Digital Signature</a>
        <a href="/digital_signature#what_is">What is it</a>
        <a href="/digital_signature#history">History</a>
        <a href="/digital_signature#uses">Uses</a>
        <a href="/digital_signature#how">How</a>
        <a href="/digital_signature#time_difference">RSA module size</a>
        <a href="/digital_signature#example">Example</a>
    </div>
    <a href="/example">Demo</a>
    <a href="/time_difference">Time difference</a>
    <a href="/about_us">About us</a>
</div>

<div class = "main">
    <h1> Digital Signatures </h1><br><br>

    <h3 id = "what_is"> What is a digital signature? </h3>

    <a>
        A digital signature is a technique that is used to validate the authenticity and integrity of a message, software, or any type of digital document.
        Some important terms to know for this are:
        <ul>
            <li> <i>Encryption</i>: The process of converting data into another for, called cipher text. </li>
            <li> <i>Decryption</i> : The process of translating cipher text back to original data, called Plaintext.</li>
            <li> <i>Public Key</i> : A key that is known to everyone.</li>
            <li> <i>Private Key</i> : A key that is known only to whose it is. </li>
            <li> <i>Authentication</i> : A process to verify the identity of a user who attempts to view the data. </li>
            <li> <i>Non-repudiation</i> : A way to guarantee that a sender of a message cannot later deny having sent the message nor that the recipient of the message cannot deny receiving it. </li>
            <li> <i>Integrity</i> : A way to ensure the message was not altered during transmission. </li>
            <li> <i>Message digest</i> : The representation of text in a form of single string digits created from a one way hash function. </li>
        </ul>


        <h3 id = "history"> Brief History of Digital Signatures</h3>

        <ul>
            <li> In 1976, Whitfield Diffie and Martin Hellman first created the idea of a digital signature scheme but only theorized this idea.</li>
            <li> In 1977, Ronald Rivest, Adi Shamir and Len Adleman created the RSA algorithm which itself can produce lower level digital signatures.</li>
            <li> All the way in 1988, Lotus Notes 1.0 was the first widely released marketed software to offer digital signatures, which used the RSA algorithm. </li>
            <li> In 1999, the ability to embed digital signatures into documents is added to a PDF format. </li>
            <li> By 2000, the ESIGN Act make digital signatures legally binding. </li>
            <li> In 2008, The PDF file format became an open standard to the International Organization for Standardization as ISO 320000 which uses digital signatures as part of the format. </li>
        </ul>

    <h3 id = "uses"> Uses: </h3>

    Digital signatures are a standard element of almost all cryptographic protocol suites but are used to meet some goals:
    <ul>
        <li> Data integrity - ensures the data was not altered during the transfer</li>
        <li> Authentication - ensures that the expected user sent the data</li>
        <li> Non-repudiation - ensures that the user did receive the data </li>
    </ul>


    <h3 id = "how"> How is it done? </h3>

    This process can be broken down into three main steps:
    <ol>
        <li> Key generation:
            A Public Key(n,e) and Private Key(n,d) are generated by, most commonly, RSA but another algorithm could be used. </li>
        <li> Signing:
            A message digest is created by applying a hash function on the Plaintext which is then encrypted using the Private Key of the sender. This results in the digital signature. </li>
        <li> Signature verification:
            The receiver decrypts the signature using the public key of the sender and computes the message digest to ensure integrity. </li>
    </ol>
    To go a little more in detail about the steps: <br><br>
    A RSA key pair is created with a certain number of bits, for our examples; we are only using a size of 1024 which is not the most secure and naturally, the larger the bit size, the harder it is to decrypt.
    With the creation of a key pair, it contains a public as well as a private key and both at some point within the encryption and verification of the signature.
    <br><br>
    Once a key pair is created, the message digest is created on the Plaintext which is encrypted using the private key by raising the data
    to the power 'd' (which is taken from the private key) modulo 'n' (taken from the public key).
    <br><br>
    Once the data is received, it is checked to see if the data was altered in some way.
    The first step is to calculate the hash value of the signed message. The original signing process is used again.
    Next, the signature is decrypted by using the public key that is correspondent to the private key that was used during the signing of the message.
    Lastly, the two hash values are compared and if they are different; the data may have been altered or the signing had an error.


    <h3 id = "time_difference"> RSA module size</h3>

    The different bit sizes used when generating the RSA key pair lies directly with how secure the key will be.
    By looking at the General Number Field Sieve (<a href = "https://en.wikipedia.org/wiki/General_number_field_sieve" target = "_blank">GFNS</a>),
    you can calculate the 'strength' of the key based on the RSA modulus size.
    The formula for GFNS is: <br> <br>
    <center>
        <img src ="../static/images/GNFS.jpg" alt="GFNS">
    </center> <br>
    where n is the number that is being factored. Evaluating the above expression at 2<sup>b</sup> is a rough approximation of the time needed to factor a b-bit integer.
    Below is a table showing the bit-length of the evaluation at 2<sup>1024</sup>, 2<sup>2048</sup>, ... <br> <br>
    <center>
        <table border = "1">
            <tr>
                <td> RSA modulus size</td>
                <td> Complexity bit-length</td>
            </tr>

            <tr>
                <td> 1024</td>
                <td> 86.76611925028119 </td>
            </tr>

            <tr>
                <td> 2048</td>
                <td> 116.8838132958159 </td>
            </tr>

            <tr>
                <td> 3072</td>
                <td> 138.7362808527251 </td>
            </tr>

            <tr>
                <td> 4096</td>
                <td> 156.49695341791272 </td>
            </tr>

            <tr>
                <td> 7680</td>
                <td> 203.01873594416484 </td>
            </tr>

            <tr>
                <td> 8192</td>
                <td> 208.47248637388102</td>
            </tr>

            <tr>
                <td> 15360</td>
                <td> 269.38477262126889</td>
            </tr>
        </table>
    </center>
    <br>

    The difference in strength of the increasing RSA modulus size can be seen in the time it takes to encrypt and validate a digital signature.
    Given the screenshot below, one can notice that the time it took for a bit size of 1024 is very low with a time of 0.25 seconds.
    With a relatively large improvement, even the 2048 RSA modulus size was able to have a time over 3 times that of the 1024 bit size.
    This is shown even more with the 3072 bit size with a whopping time of 8.87 seconds which is over 10 times longer than that of 2048 bits.
    This could even be shown further like in the table. <br> <br>
    <center>
        <img src ="../static/images/three_times.jpg" alt="time difference"> <br>
    </center> <br>
    <h5> Note: </h5>
    The code that produced these snippets can be found at (Currently a private repository):
    <a href = "https://github.com/M3ritt/Digital-Signatures/tree/master/Demonstration" target = "_blank"> GitHub </a> <br> <br>

    This can be played around with using the <a href="/time_difference">Time difference</a> page. <br>
    <i> Additional Note: This only allows two different bit sizes to be checked </i>


    <h3 id = "example"> Example </h3>

    A sample program was created to show data, in this case it is only text, going through the steps of having a digital signature made for it.
    Then, a user can enter either the same text or something else to show the 'data' being altered or not.
    Lastly, it shows whether the signature is valid or not.
    The screenshots provided also show the public and private keys along with the hashes of the original and new data.

    <h5> Correct signature: </h5>
    <img src ="../static/images/final_valid_signature.jpg" alt="Correct signature"> <br>

    This example has the user enter two types of data that are the same, i.e. not tampered with.
    Since the data was not tampered with, the hashes or the new data are the same, i.e.
    the signatures are the same and the signature is verified.


    <h5> Incorrect signature: </h5>
    <img src ="../static/images/final_invalid_signature.jpg"  alt="Incorrect signature"> <br>

    This example has the user enter two types of data that are not the same, i.e. tampered with.
    Since the data was tampered with, the hashes or the new data are different, i.e.
    the signatures are different and the signature is not verified.


    <br>
    <h5> Note: </h5>
    The code that produced these snippets can be found on:
        <a href = "https://github.com/M3ritt/Digital-Signatures/tree/master/Demonstration" target = "_blank"> GitHub </a>
    </a>

    <h3> Resources: </h3>
    <ul>
        <li> “Security Tip (ST04-018).” Cybersecurity and Infrastructure Security Agency CISA, 2020, us-cert.cisa.gov/ncas/tips/ST04-018. </li>
        <li> U.S. Department of Commerce, Digital Signature Standard (DSS). Gaithersburg: National Institute of Standards and Technology, July. 2013, http://dx.doi.org/10.6028/NIST.FIPS.186-4</li>
        <li> Richard Crandall and Carl Pomerance. Prime Numbers: A Computational Perspective (2001). 2nd edition, Springer. ISBN 0-387-25282-7. Section 6.2: Number field sieve, pp. 278–301.</li>
    </ul>
    <br><br><br><br><br>
</div>
<script src="{{ url_for('static', filename='js/navigation_bar_loop.js') }}"></script>
</body>
</html>
